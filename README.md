![ACM-ICPC](https://github.com/NAU-ACM/ACM-ICPC-Preparation/blob/master/acm_icpc_prep.jpg "ACM-ICPC")

# ACM-ICPC Preparation 
![](https://img.shields.io/badge/licence-MIT-green.svg) ![](https://img.shields.io/badge/Weeks%20Completed-8%2F20-orange.svg) ![](https://img.shields.io/badge/Revisions-2%2F20-red.svg)

This curriculum has been developed to learn Algorithms to use in Competitive Programming, **but can also be used for:**
  - Practicing for Interviews
  - Improving Algorithmic Thinking
  - Practicing for College Classes

**Prerequisites:** 
  - To know at least one programming language. (_You have to be able to use the language efficiently._)
  - You have to be familiar with some of the primary Data Structures (Array, Stack, Queue, etc.) (_Although if you don't know some, you may learn when you come across them._)

The concept of this repository is to have well-structured content divided into parts that one can follow even if they are busy. Here we collected sources we find well prepared to learn the proposed topics. The curriculum has different data structures and algorithms. 

**Estimated time required for a week is 6-7 hours.** (To complete the curriculum in the given time)

**Basic usage guide:**
Using this repository depends on what the user wants to do with it. Here we are suggesting the following for people who want to slowly gain knowledge of the topics while continuing their studies etc.:
  1. Check out the written or video sources provided for a given topic depending on the preference. Go over as many as needed to gain a good understanding of the topic.
  2. Without checking the source code, try to replicate the algorithm or data structure on your own.
  3. When stuck or when done, look at the source codes provided, and compare them with yours to see what might be your mistake. Try to fix it.
  4. After you feel comfortable with the code, try to solve the given problems.
  5. When you are done with solving or are stuck at some point, check given solutions and try to understand your mistake or see if a better approach exists.

## Resources

Here are some of the websites/tools that we use through this curriculum:

  - [Leetcode](https://leetcode.com)
  - [Spoj](http://www.spoj.com)
  - [Hackerrank](https://www.hackerrank.com/domains)
  - [Topcoder](https://www.topcoder.com)
  - [Codeforces](http://codeforces.com)
  - [Lightoj](http://www.lightoj.com)
  - [ACM-Timus](http://acm.timus.ru)

## Contribution

If you have anything to add, do not hesitate to offer! You can check [Code of Conduct](CODE_OF_CONDUCT.md). You can submit a PR or an issue; I will try to personally review all.

## Topics

Here are the topics we currently include in the curriculum.

### Data Structures
  - Stacks
  - Queues
  - Priority queue
  - Hashmap
  - Linked List
  - Trees
  - Heaps
  - Advanced Trees 
    - Tries
    - Segment trees
    - Fenwick tree or Binary indexed trees
    - RMQ
  - SQRT Decomposition
  - Disjoint Data Structure
  - C++ STL (optional)

### Algorithms
  - Number Theory 
    - Prime Numbers (Sieve of Eratosthenes)
    - GCD and LCM Euclid’s Algorithm
    - Modular Exponentiation
    - Long arithmetic (Multi, Add)
    - Efficient Prime Factorization

  - Combinatorics (Probability-Combinations-Permutations-Matrix..)

  - Computational Geometry
    - Primitive Operations
      - Intuition
      - Polygon Inside, Outside
      - Implementing CCW
      - Immutable Point ADT
    - Convex Hull
    - Closest pair problem
    - Line intersection

  - Sort
    - QuickSort
    - Counting Sort
    - Merge Sort

  - Search
    - Binary Search
    - Ternary Search

  - Graph Theory
    - Depth First Search (DFS)
    - Breadth First Search (BFS)
    - Dijkstra’s Shortest Path
    - Minimum Spanning Tree 
    - Ford Bellman
    - Floyd Warshall
    - LCA (Lowest Common Ancestor)
    - Max Flow / Min Cut

  - Dynamic Programming
    - Knapsack
    - Matrix chain multiplication
    - Coin Change
    - Kadane
    - Longest increasing Subsequence (with RMQ)

  - Strings
    - Z algorithm
    - Suffix Trees/Arrays
    - Knuth-Morris-Pratt Algorithm (KMP)
    - Rabin-Karp Algorithm
    - Hash

  - Bit Manipulation

  - Game theory
    - Nim game
    - Grundy numbers
    - Sprague-Grundy theorem

  - **Optional Advanced Algorithms**
    - AVL Trees
    - Graph Coloring
    - Mo's Algorithm
    - Palindromic Tree
    - Heavy Light Decomposition
    - Dynamic Programming by Profile
    - Rod Cutting
    - Topological Sorting
    - DP with Bitmask - Dynamic Programming
    - Diobhantine Equation - Math
    - Flood Fill - Graph


## Curriculum
|Week|Topics|Optional Topics|
| --- | --- | --- |
|[**Heads Up **](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week00)|<ul><li>Big O Notation</li></ul>||
|[**1.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week01)|<ul><li>Prime Numbers (Sieve of Eratosthenes)</li><li>Efficient Prime Factorization</li><li>Modular Exponentiation</li></ul>||
|[**2.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week02)|<ul><li>GCD and LCM Euclid’s Algorithm</li><li>Long arithmetic (Multi, Sum, Div, Sub)</li></ul>|<ul><li>C++ STL:Vector</li><li>C++ STL:Pairs</li><li>C++ STL:Iterators</li></ul>|
|[**3.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week03)|<ul><li>QuickSort</li><li>Counting Sort</li></ul>|<ul><li>C++ STL:String</li><li>C++ STL:Set</li><li>C++ STL:Map</li></ul>|
|[**4.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week04)|<ul><li>Merge Sort</li><li>Binary Search</li></ul>|<ul><li>Ternary Search</li></ul>|
|[**5.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week05)|<ul><li>Queue (DS)</li><li>Stack (DS)</li><li>Breadth First Search</li><li>Depth First Search</li></ul>|<ul><li>C++ STL: Queue</li><li>C++ STL: Stack</li></ul>|
|[**6.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week06)|<ul><li>Linked List (DS)</li><li>Dijkstra’s Shortest Path</li><li>Minimum Spanning Tree (MST)</li><li>Floyd Warshall</li></ul>|<ul><li>Cycle Detection (Union Find)</li></ul>|
|[**7.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week07)|<ul><li>Knapsack</li><li>Coin Change</li><li>Kadane</li></ul>||
|[**8.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week08)|**Questions from previous topics**||
|[**9.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week09)|<ul><li>Trees (DS)</li><li>Segment Trees (DS)</li><li>Range Minimum Query (RMQ)</li><li>Lowest Common Ancestor (LCA)</li></ul>|<ul><li>Topological Sorting</li></ul>|
|[**10.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week10)|<ul><li>Ford Bellman</li><li>Max Flow / Min Cut</li><li>Longest increasing Subsequence (with RMQ)</li></ul>|<ul><li>Heavy Light Decomposition</li></ul>|
|[**11.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week11)|<ul><li>Primitive Operations<ul><li>Intuition</li><li>Polygon Inside, Outside</li><li>Implementing CCW</li><li>Immutable Point ADT</li></ul></li><li>Convex Hull</li><li>Closest pair problem</li><li>Line intersection</li></ul>||
|[**12.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week12)|<ul><li>Tries (DS)</li><li>Suffix Trees/Arrays (DS)</li><li>Knuth-Morris-Pratt Algorithm (KMP)</li><li>Rabin-Karp Algorithm</li></ul>||
|[**13.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week13)|<ul><li>Heaps (DS)</li><li>Priority queue (DS)</li><li>Combinatorics</li></ul>||
|[**14.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week14)|<ul><li>Z algorithm</li><li>Hash</li><li>Disjoint Data Structure (DS)</li></ul>||
|[**15.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week15)|<ul><li>Matrix chain multiplication</li><li>SQRT Decomposition (DS)</li></ul>|<ul><li>Mo's Algorithm</li><li>Rod Cutting</li></ul>|
|[**16.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week16)|**Questions from previous topics**||
|[**17.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week17)|<ul><li>Nim game</li><li>Grundy numbers</li></ul>||
|[**18.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week18)|<ul><li>Sprague-Grundy theorem</li><li>Fenwick tree or Binary indexed trees (DS)</li></ul>||
|[**19.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week19)|<ul><li>Bit Manipulation</li></ul>|<ul><li>Palindromic Tree</li><li>AVL Trees</li></ul>|
|[**20.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week20)|<ul><li>Heavy Light Decomposition</li><li>Dynamic Programming by Profile</li></ul>|<ul><li>Graph Coloring</li></ul>|

### [Contributers](https://github.com/NAU-ACM/ACM-ICPC-Preparation/graphs/contributors)
